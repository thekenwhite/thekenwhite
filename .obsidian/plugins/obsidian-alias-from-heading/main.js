/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AliasFromHeadingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var AliasFromHeadingPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "removeMetadataCachePatch");
  }
  onload() {
    const { metadataCache, vault, workspace } = this.app;
    const headingByPath = /* @__PURE__ */ new Map();
    function getHeading(file) {
      const { headings } = metadataCache.getFileCache(file);
      if (!Array.isArray(headings) || !headings.length) {
        return;
      }
      const { heading } = headings[0];
      return heading;
    }
    const clearHeadings = (0, import_obsidian.debounce)((path) => {
      if (!headingByPath.has(path)) {
        return;
      }
      const heading = headingByPath.get(path);
      headingByPath.clear();
      headingByPath.set(path, heading);
    }, 1e4, true);
    function loadFile(file) {
      if (!file) {
        return;
      }
      const { path } = file;
      const heading = getHeading(file);
      headingByPath.set(path, heading);
      clearHeadings(path);
    }
    workspace.onLayoutReady(() => {
      const activeFile = workspace.getActiveFile();
      loadFile(activeFile);
    });
    this.registerEvent(workspace.on("file-open", loadFile));
    this.registerEvent(vault.on("rename", (file, oldPath) => {
      if (!(file instanceof import_obsidian.TFile)) {
        return;
      }
      const { path } = file;
      const heading = headingByPath.get(oldPath);
      headingByPath.set(path, heading);
    }));
    this.registerEvent(metadataCache.on("changed", (file) => __async(this, null, function* () {
      const { path } = file;
      if (!headingByPath.has(path)) {
        return;
      }
      const prevHeading = headingByPath.get(path);
      const heading = getHeading(file);
      headingByPath.set(path, heading);
      if (prevHeading === heading) {
        return;
      }
      const modifiedFiles = Object.entries(metadataCache.resolvedLinks).reduce((paths, [toPath, links]) => {
        const hasRef = Object.keys(links).includes(path);
        return hasRef ? [...paths, toPath] : paths;
      }, []).map((p) => {
        const { links = [] } = metadataCache.getCache(p);
        const linksToReplace = links.filter((rc) => {
          var _a;
          const [link] = rc.link.split("#");
          return ((_a = metadataCache.getFirstLinkpathDest(link, "")) == null ? void 0 : _a.path) === path;
        }).map((rc) => {
          var _a, _b, _c, _d;
          const { original } = rc;
          const mdLinkRE = new RegExp("^\\[(.*)\\]\\((?<link>.*)\\)$");
          const mdLink = (_b = (_a = original.match(mdLinkRE)) == null ? void 0 : _a.groups) == null ? void 0 : _b.link;
          if (mdLink) {
            return [
              `[${escapeMDLinkName(prevHeading)}](${mdLink})`,
              `[${escapeMDLinkName(heading)}](${mdLink})`
            ];
          }
          const wikiLinkRE = new RegExp("^\\[\\[(?<link>.*?)\\|.*\\]\\]$");
          const wikiLink = (_d = (_c = original.match(wikiLinkRE)) == null ? void 0 : _c.groups) == null ? void 0 : _d.link;
          if (wikiLink) {
            return [
              `[[${wikiLink}|${escapeWikiLinkName(prevHeading)}]]`,
              `[[${wikiLink}|${escapeWikiLinkName(heading)}]]`
            ];
          }
        }).filter((i) => i);
        return [p, linksToReplace];
      }).filter(([, linksToReplace]) => linksToReplace.length).map((_0) => __async(this, [_0], function* ([p, linksToReplace]) {
        const f = vault.getAbstractFileByPath(p);
        let matches = 0;
        yield vault.process(
          f,
          (data) => linksToReplace.reduce(
            (source, [find, replace]) => {
              const re = new RegExp(escapeRegExp(find), "g");
              return source.replace(re, () => {
                matches++;
                return replace;
              });
            },
            data
          )
        );
        return matches;
      }));
      const linkMatches = (yield Promise.all(modifiedFiles)).filter((m) => m);
      const fileCount = linkMatches.length;
      const linkCount = linkMatches.reduce((sum, value) => sum + value, 0);
      if (!fileCount || !linkCount) {
        return;
      }
      new import_obsidian.Notice(`Updated ${linkCount} ${pluralize(linkCount, "link")} in ${fileCount} ${pluralize(fileCount, "file")}.`);
    })));
    this.removeMetadataCachePatch = patch(metadataCache, {
      getCache(originalMethod) {
        return function(path) {
          const cache = originalMethod(path);
          const _cache = cache || {};
          const { headings = [] } = _cache;
          if (!Array.isArray(headings) || !headings.length) {
            return cache;
          }
          const { frontmatter = {} } = _cache;
          const { aliases: _aliases = [] } = frontmatter;
          const aliases = Array.isArray(_aliases) ? _aliases : [_aliases];
          const { heading } = headings[0];
          if (aliases.includes(heading)) {
            return cache;
          }
          return __spreadProps(__spreadValues({}, _cache), {
            frontmatter: __spreadProps(__spreadValues({}, frontmatter), {
              aliases: [heading, ...aliases]
            })
          });
        };
      }
    });
  }
  onunload() {
    this.removeMetadataCachePatch();
  }
};
function escapeMDLinkName(source) {
  return source.replace(/[\[\]]/g, "\\$&");
}
function escapeWikiLinkName(source) {
  return source.replace(
    /(\[{2,}|\]{2,})/g,
    (match) => match.split("").map((m) => `\\${m}`).join("")
  );
}
function escapeRegExp(source) {
  return source.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function patch(source, methods) {
  const removals = Object.entries(methods).map(([key, createMethod]) => {
    const hadOwn = source.hasOwnProperty(key);
    const method = source[key];
    source[key] = createMethod(method.bind(source));
    return function remove() {
      if (hadOwn) {
        source[key] = method;
      } else {
        delete source[key];
      }
    };
  });
  return () => removals.forEach((r) => r());
}
function pluralize(count, singular, plural = `${singular}s`) {
  return count === 1 ? singular : plural;
}

/* nosourcemap */